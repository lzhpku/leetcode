{\rtf1\ansi\ansicpg936\cocoartf1404\cocoasubrtf340
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs24 \cf0 You are given a m x n 2D grid initialized with these three possible values.\
\
-1 - A wall or an obstacle.\
0 - A gate.\
INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647.\
Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF.\
\
For example, given the 2D grid:\
INF  -1  0  INF\
INF INF INF  -1\
INF  -1 INF  -1\
  0  -1 INF INF\
After running your function, the 2D grid should be:\
  3  -1   0   1\
  2   2   1  -1\
  1  -1   2  -1\
  0  -1   3   4\
\
public class Solution \{\
    public void wallsAndGates(int[][] rooms) \{\
        for(int i = 0; i < rooms.length; i ++)\
            for(int j = 0; j < rooms[0].length; j ++)\
                if(rooms[i][j] == 0)\
                    dfs(rooms, i, j, 0);\
    \}\
    \
    public void dfs(int[][] rooms, int i, int j, int dis) \{\
        if(i < 0 || i >= rooms.length || j < 0 || j >= rooms[0].length || rooms[i][j] < dis)\
            return;\
        rooms[i][j] = dis;\
        dfs(rooms, i + 1, j, dis + 1);\
        dfs(rooms, i - 1, j, dis + 1);\
        dfs(rooms, i, j + 1, dis + 1);\
        dfs(rooms, i, j - 1, dis + 1);\
    \}\
\}}